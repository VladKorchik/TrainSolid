Здравствуйте. 
Работа приложения протестирована в классе Main, для удобства добавил в нём комментарии. 

S: Приложение разделено на классы и пакеты, у каждого своя ответственность. Пакет Customer отвечает за пользователя и его продуктовую корзину (в пакете как раз два класса, Customer и ShoppingCart). Методы для работы с корзиной, например, вывести всю корзину или добавить в неё товар, находятся также в классе ShoppingCart. В пакете Products находятся исключительно товары и предназначенные им интерфейсы. 
O: В качесте примера можно привести стандартные методы класса Product пакета Products. 
Также, если я правильно понял принцип, то этот принцип имеет нечто схожее с принципом Dependency inversion principle, о реализации которого написано чуть ниже. 
L: В моём примере классы Fridge и HeadPgones являются наследниками класса Product. Это сделано для того, чтобы иметь возможность добавлять им дополнительные поля. Например, у холодильнкиа это вес (поле weight), а у наушников - диапазон воспроизводимых частот (поле range). Товары, которым эти поля не нужны, можно создавать с типом Product, как это было продемонстрировано на примере тарелки в классе Main.
I: В качестве примера я создал интерфейс IDelivery, который наследуется крупногабаритными товарами (в моём примере классом Fridge). У этого интерфейса также есть соответствующий метод deliver.
D: Пакет Customer, класс ShoppingCart. Поле класса customerShoppingCart, как и метод addProductToCart, завязаны не на объектах, а на интерфейсах. Таким образом, можно создать совсем иной класс продуктов, отличный от класса Product, но дать ему отнаследовать интерфейс IProduct, благодаря чему нам не придёться менять класс ShoppingCart, 
